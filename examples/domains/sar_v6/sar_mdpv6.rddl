// *** What's missing
// Tool depletion
// Victims under rubble
// Issues related to time
// 	Players moving at different speeds
// 	Victims taking different time to triage

domain sar_mdpv6 {
	
	requirements = { 
		constrained-state,
		reward-deterministic
	};
	
	types {
  		player : object;
 	  	loc    : object;
        	victim: object;
		tool      : { @hammer, @medic, @stretcher};
		vstate: {@saved, @unsaved, @frozen};	//critical victims start out frozen
		dir: {@n, @s, @e, @w, @none};
	}; 	
	pvariables { 	
		// Map: basic connections and booleans for indicating clear vs rubble
		conn(loc, loc) : { non-fluent, dir, default = @none} ;	
		clear(loc, loc) : { state-fluent, bool, default = true} ;	

		// Recharging location
		isRechargeLoc(loc): { non-fluent, bool, default = false };
		// Threats/freezing tiles
		isThreatLoc(loc): { non-fluent, bool, default = false };
		isActiveThreatLoc(loc): { state-fluent, bool, default = false };

		// Player and victim locations
		pLoc(player, loc) : { state-fluent, bool, default = false };
		vLoc(victim, loc) : { state-fluent, bool, default = false };
						
		// Move actions 
		move_n(player): { action-fluent, bool, default = false};
		move_s(player): { action-fluent, bool, default = false};
		move_e(player): { action-fluent, bool, default = false};
		move_w(player): { action-fluent, bool, default = false};
		canMove(player) : { state-fluent, bool, default = true };
		
		// Victim predicates
		vicState(victim) : { state-fluent, vstate, default = @unsaved} ;
		isCritical(victim) :  { non-fluent, bool, default = false };
		triage(player, victim): { action-fluent, bool, default = false };
		pickupVictim(player, victim): { action-fluent, bool, default = false };
		hasVictim(player, victim): { state-fluent, bool, default = false };
		dropVictim(player, victim): { action-fluent, bool, default = false };

		// Tool predicates
		hasTool(player, tool) : { state-fluent, bool, default = false} ;
		pickTool(player, tool) : { action-fluent, bool, default = false };
		applyHammer(player)  : { action-fluent, bool, default = false };

		// No op
		noop(player)  : { action-fluent, bool, default = false };
	};
  
	cpfs {		
		pLoc'(?p, ?lc) = 
			if ((move_n(?p) + move_s(?p) + move_e(?p) + move_w(?p) )  == 0)
			then pLoc(?p, ?lc)
			else if (move_n(?p) ^ exists_{?lc2 : loc} [ pLoc(?p, ?lc2) ^  (conn(?lc2, ?lc) == @n) ^ clear(?lc2, ?lc)])
				then KronDelta(true)
			else if (move_s(?p) ^ exists_{?lc2 : loc} [ pLoc(?p, ?lc2) ^  (conn(?lc2, ?lc) == @s) ^ clear(?lc2, ?lc)])
				then KronDelta(true)
			else if (move_e(?p) ^ exists_{?lc2 : loc} [ pLoc(?p, ?lc2) ^  (conn(?lc2, ?lc) == @e) ^ clear(?lc2, ?lc)])
				then KronDelta(true)
			else if (move_w(?p) ^ exists_{?lc2 : loc} [ pLoc(?p, ?lc2) ^  (conn(?lc2, ?lc) == @w) ^ clear(?lc2, ?lc)])
				then KronDelta(true)
			else KronDelta(false);
	
		vicState'(?v) = 
			if (  (vicState(?v) == @unsaved) ^ exists_{?p : player} [ triage(?p, ?v)  ] )
				then @saved
			else if (  (vicState(?v) == @frozen) ^ (exists_{?lc : loc} [vLoc(?v, ?lc) ^ forall_{?p : player}  pLoc(?p, ?lc)] )  )
				then @unsaved
			else vicState(?v);	

		hasTool'(?p, ?t) = 
			if (pickTool(?p, ?t))
				then KronDelta(true)
			// if you didn't pick this tool in the prev time step, but you picked some tool, you no longer have this tool
			else if (  (sum_{?t2 : tool} [pickTool(?p, ?t2)])   == 1)
				then  KronDelta(false)
			// else no change
			else hasTool(?p, ?t);

		clear'(?lc1, ?lc2) = 
			if ( exists_{?p : player} [ pLoc(?p, ?lc1)  ^  applyHammer(?p)]  )
				then KronDelta(true)
			else clear(?lc1, ?lc2);
		
		hasVictim'(?p, ?v) = 
			if (pickupVictim(?p, ?v))
				then KronDelta(true)
			else if (dropVictim(?p, ?v))
				then KronDelta(false)
			else hasVictim(?p, ?v);
		
		vLoc'(?v, ?lc) = 
			// If someone just picked up a victim, that victim is "nowhere"
			if (exists_{?p : player} [pickupVictim(?p, ?v) ])  
				then KronDelta(false)
			// if someone dropped victim here, then true
			else if (exists_{?p : player} [dropVictim(?p, ?v) ^ pLoc(?p, ?lc)])
				then KronDelta(true)
			else vLoc(?v, ?lc);

		isActiveThreatLoc'(?lc) = 
			// if a player was there moved, then threat fired once and is no longer active (regardless of whether it was actually a threat). Else unchanged
			if (exists_{?p : player} [pLoc(?p, ?lc) ^ ~pLoc'(?p, ?lc)])
				then KronDelta(false)
			else isActiveThreatLoc(?lc);

		canMove'(?p) = 
			// if there's a medic around, you can move. Regardless of whether this is a threat location or you were frozen
			if (exists_{?lc : loc} [ pLoc(?p, ?lc) ^ ( exists_{?p2 : player}  (?p ~= ?p2) ^ pLoc(?p2, ?lc) ^ hasTool(?p2, @medic)) ] )
				then KronDelta(true)
			else if (exists_{?lc : loc} [ pLoc'(?p, ?lc) ^  isThreatLoc(?lc) ^  isActiveThreatLoc(?lc) ] )
				then KronDelta(false)
			else canMove(?p);
			
	};		
	reward = 	
		[sum_{?v: victim} 
			[   (vicState(?v) == @saved)  * (  1 - isCritical(?v) +  5 * isCritical(?v   )) ] ]
//		 +
//		[ sum_{?vi: victim} 
//			[ sum_{?p : player} 
//				[ hasVictim(?p, ?vi) ]  ] ]
//		 +
//		[ sum_{?vi: victim} 
//			[ sum_{?p : player} 
//				[ dropVictim(?p, ?vi) ]  ] ]
		;

	state-action-constraints {
		// Only 1 action per player at a time
		forall_{?p: player}  ( move_n(?p) + move_s(?p) + move_e(?p) + move_w(?p)  +   
						noop(?p) + 
						(sum_{?v: victim} [triage(?p, ?v)] + pickupVictim(?p, ?v) + dropVictim(?p, ?v) )  +  
						(sum_{?t: tool} [pickTool(?p, ?t)])  +
						applyHammer(?p)
				 == 1 );

		// Only 1 player can pick up a victim
		forall_{?v : victim} [  ( sum_{?p : player} pickupVictim(?p, ?v) ) <= 1];
	};

    action-preconditions {
	// To move in a direction, you must be  not frozen and there's space to move
	forall_{?p : player} 
		[ move_n(?p) => canMove(?p) ^ exists_{?lc1: loc} pLoc(?p, ?lc1) ^ [exists_{?lc2 : loc} (conn(?lc1, ?lc2) == @n) ^ clear(?lc1, ?lc2)] ];
	forall_{?p : player} 
		[ move_s(?p) => canMove(?p) ^ exists_{?lc1: loc} pLoc(?p, ?lc1) ^ [exists_{?lc2 : loc} (conn(?lc1, ?lc2) == @s) ^ clear(?lc1, ?lc2)] ];
	forall_{?p : player} 
		[ move_e(?p) => canMove(?p) ^ exists_{?lc1: loc} pLoc(?p, ?lc1) ^ [exists_{?lc2 : loc} (conn(?lc1, ?lc2) == @e) ^ clear(?lc1, ?lc2)] ];
	forall_{?p : player} 
		[ move_w(?p) => canMove(?p) ^ exists_{?lc1: loc} pLoc(?p, ?lc1) ^ [exists_{?lc2 : loc} (conn(?lc1, ?lc2) == @w) ^ clear(?lc1, ?lc2)] ];

	// To apply a hammer, you must have it
	forall_{?p : player} 
		[ applyHammer(?p) => hasTool(?p, @hammer) ];

	// To pick a tool, you must be at the recharging station
	forall_{?p : player} 
		[forall_{?t : tool} 
			[ pickTool(?p, ?t) =>  exists_{?lc : loc} [pLoc(?p, ?lc) ^ isRechargeLoc(?lc) ] ]  	];
			
	// To triage a victim, you must be a medic, victim must be unsaved and you must be in the same location
	forall_{?p : player} 
		[forall_{?v : victim} 
			[ triage(?p, ?v) => (hasTool(?p, @medic)  ^ (vicState(?v) == @unsaved) ^ exists_{?lc : loc} [pLoc(?p, ?lc) ^ vLoc(?v, ?lc) ] )]  	];
	
	// To pick up a victim, you must have a stretcher, victim can't be critical, no one else is carrying the victim, and you must be in the same location
	forall_{?p : player} 
		[forall_{?v : victim} 
			[ pickupVictim(?p, ?v) =>  hasTool(?p, @stretcher)  ^ (~ isCritical(?v) ) ^  (  forall_{?otherv : victim} [~ hasVictim(?p, ?otherv)]  ) ^    exists_{?lc : loc} [pLoc(?p, ?lc) ^ vLoc(?v, ?lc) ] ]  	];
			
	// To drop up a victim, you must have the victim
	forall_{?p : player} 
		[forall_{?v : victim} 
			[ dropVictim(?p, ?v) =>  hasVictim(?p, ?v)  	] ];
			
	};
}
